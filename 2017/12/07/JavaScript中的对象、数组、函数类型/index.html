<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#3DC7BE">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-bounce.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/tian.jpg?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/tian.jpg?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/tian.jpg?v=5.1.3">


  <link rel="mask-icon" href="/images/tian.jpg?v=5.1.3" color="#3DC7BE">





  <meta name="keywords" content="JavaScript," />










<meta name="description" content="Object 类型Object 是使用最多的一个类型。虽然 Object 的实例不具备多少功能，但对于在应用程序中存储和传输数据而言，它们确实是非常理想的选择。 创建 Object 实例的方式有两种。第一种是使用 new 操作符后跟 Object 构造函数，如下所示: 123var person = new Objec">
<meta name="keywords" content="JavaScript">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript 中的对象、数组、函数类型">
<meta property="og:url" content="http://yoursite.com/2017/12/07/JavaScript中的对象、数组、函数类型/index.html">
<meta property="og:site_name" content="田丰的笔记本子">
<meta property="og:description" content="Object 类型Object 是使用最多的一个类型。虽然 Object 的实例不具备多少功能，但对于在应用程序中存储和传输数据而言，它们确实是非常理想的选择。 创建 Object 实例的方式有两种。第一种是使用 new 操作符后跟 Object 构造函数，如下所示: 123var person = new Object();person.name = &quot;Nicholas&quot;;person.age">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2017-12-10T15:18:02.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JavaScript 中的对象、数组、函数类型">
<meta name="twitter:description" content="Object 类型Object 是使用最多的一个类型。虽然 Object 的实例不具备多少功能，但对于在应用程序中存储和传输数据而言，它们确实是非常理想的选择。 创建 Object 实例的方式有两种。第一种是使用 new 操作符后跟 Object 构造函数，如下所示: 123var person = new Object();person.name = &quot;Nicholas&quot;;person.age">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":true},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/12/07/JavaScript中的对象、数组、函数类型/"/>





  <title>JavaScript 中的对象、数组、函数类型 | 田丰的笔记本子</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta custom-logo">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">田丰的笔记本子</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/07/JavaScript中的对象、数组、函数类型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="田丰">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://p05mkbfri.bkt.clouddn.com/bye.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="田丰的笔记本子">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">JavaScript 中的对象、数组、函数类型</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-07T09:31:42+08:00">
                2017-12-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h2><p><code>Object</code> 是使用最多的一个类型。虽然 <code>Object</code> 的实例不具备多少功能，但对于在应用程序中<strong>存储和传输数据</strong>而言，它们确实是非常理想的选择。</p>
<p>创建 <code>Object</code> 实例的方式有<strong>两种</strong>。第一种是使用 <code>new</code> 操作符后跟 <code>Object</code> 构造函数，如下所示:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">person.age = <span class="number">29</span>;</span><br></pre></td></tr></table></figure>
<p>另一种方式是使用<strong>对象字面量</strong>表示法。<strong>对象字面量</strong>是对象定义的一种简写形式，目的在于<strong>简化</strong>创建包含<strong>大量属性</strong>的对象的过程。在通过对象字面量定义对象时，实际上<strong>不会调用</strong> <code>Object</code> 构造函数。下面这个例子使用对象字面量语法定义了与前面那个例子中相同的 <code>person</code> 对象:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name : <span class="string">"Nicholas"</span>,</span><br><span class="line">  age : <span class="number">29</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在使用对象字面量语法时，属性名<strong>也可以使用字符串</strong>，如下面这个例子所示:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="string">"name"</span> : <span class="string">"Nicholas"</span>,</span><br><span class="line">  <span class="string">"age"</span> : <span class="number">29</span>,</span><br><span class="line">  <span class="number">5</span> : <span class="literal">true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个例子会创建一个对象，包含三个属性:<code>name</code>、<code>age</code> 和 <code>5</code>。但这里的数值属性名会<strong>自动转换为字符串</strong>。</p>
<blockquote>
<p>关于<strong>对象字面量语法</strong>，推荐只在考虑<strong>对象属性名的可读性</strong>时使用。</p>
</blockquote>
<p>虽然可以使用前面介绍的任何一种方法来定义对象，但开发人员<strong>更青睐对象字面量语法</strong>，因为这种语法要求的<strong>代码量少</strong>，而且能够<strong>给人封装数据的感觉</strong>。对象字面量也是<strong>向函数传递大量可选参数的首选方式</strong>，例如:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">displayInfo</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> output = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//通过typeof操作符来检测每个属性是否存在</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> args.name == <span class="string">"string"</span>) &#123;</span><br><span class="line">      output += <span class="string">"Name: "</span> + args.name + <span class="string">"\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> args.age == <span class="string">"number"</span>) &#123;</span><br><span class="line">      output += <span class="string">"Age: "</span> + args.age + <span class="string">"\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  alert(output);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">displayInfo(&#123;</span><br><span class="line">  name: <span class="string">"Nicholas"</span>,</span><br><span class="line">  age: <span class="number">29</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">displayInfo(&#123;</span><br><span class="line">  name: <span class="string">"Greg"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这种传递参数的模式<strong>最适合需要向函数传入大量可选参数的情形</strong>。一般来讲，<strong>命名参数</strong>虽然容易处理，但在有<strong>多个可选参数</strong>的情况下就会<strong>显示不够灵活</strong>。最好的做法是<strong>对那些必需值使用命名参数</strong>，而<strong>使用对象字面量来封装多个可选参数</strong>。</p>
<p>一般来说，访问对象属性时使用的都是<strong>点表示法</strong>，不过，在 JavaScript 也可以使用<strong>方括号表示法</strong>来访问对象的属性。在使用方括号语法时，应该将要访问的属性<strong>以字符串的形式放在方括号中</strong>，如下面的例子所示:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(person[<span class="string">"name"</span>]); <span class="comment">//"Nicholas"</span></span><br><span class="line">alert(person.name); <span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure>
<p>从<strong>功能上看</strong>，这两种访问对象属性的方法<strong>没有任何区别</strong>。但<strong>方括号语法</strong>的主要优点是<strong>可以通过变量来访问属性</strong>，例如:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> propertyName = <span class="string">"name"</span>;</span><br><span class="line">alert(person[propertyName]); <span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure>
<p>如果属性名中<strong>包含会导致语法错误的字符</strong>，或者<strong>属性名使用的是关键字或保留字</strong>，也可以使用<strong>方括号表示法</strong>。例如:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person[<span class="string">"first name"</span>] = <span class="string">"Nicholas"</span>;</span><br></pre></td></tr></table></figure>
<p>由于 <code>&quot;first name&quot;</code> 中包含一个空格，所以<strong>不能使用点表示法</strong>来访问它。然而，<strong>属性名</strong>中是<strong>可以包含非字母非数字</strong>的，这时候就可以使用<strong>方括号表示法</strong>来访问它们。</p>
<h2 id="Array-类型"><a href="#Array-类型" class="headerlink" title="Array 类型"></a>Array 类型</h2><p>JavaScript 中数组的每一项可以保存<strong>任何类型</strong>的数据，大小可以<strong>动态调整</strong>的。</p>
<p>创建数组的基本方式有<strong>两种</strong>。<strong>第一种</strong>是使用 <code>Array</code> <strong>构造函数</strong>，如下面的代码所示:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br></pre></td></tr></table></figure>
<p>如果<strong>预先知道</strong>数组要保存的<strong>项目数量</strong>，也可以给构造函数<strong>传递该数量</strong>，而该数量会自动变成 <code>length</code> 属性的值。例如，下面的代码将创建 <code>length</code> 值为 <code>20</code> 的数组:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure>
<p>也可以向 <code>Array</code> 构造函数传递数组中应该<strong>包含的项</strong>。以下代码创建了一个包含 3 个字符串值的数组:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>);</span><br></pre></td></tr></table></figure>
<p>给构造函数传递<strong>一个值</strong>也可以创建数组。如果传递的是<strong>数值</strong>，则会按照该数值创建包含<strong>给定项数量</strong>的数组；而如果传递的是<strong>其他类型</strong>的参数，则会创建<strong>包含那个值</strong>的<strong>只有一项</strong>的数组。下面有两个例子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>); <span class="comment">//创建一个包含 3 项的数组</span></span><br><span class="line"><span class="keyword">var</span> names = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"Greg"</span>); <span class="comment">//创建一个包含 1 项，即字符串"Greg"的数组</span></span><br></pre></td></tr></table></figure>
<p>在使用 <code>Array</code> 构造函数时也可以<strong>省略</strong> <code>new</code> 操作符。省略 <code>new</code> 操作符的<strong>结果相同</strong>。</p>
<p>创建数组的<strong>第二种</strong>基本方式是使用<strong>数组字面量表示法</strong>。数组字面量由一对包含数组项的<strong>方括号</strong>表示，多个数组项之间以<strong>逗号隔开</strong>。与对象一样，在使用数组字面量表示法时，也<strong>不会调用</strong> <code>Array</code> 构造函数。如下所示:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]; <span class="comment">//创建一个包含 3 个字符串的数组</span></span><br><span class="line"><span class="keyword">var</span> names = []; <span class="comment">//创建一个空数组</span></span><br><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,]; <span class="comment">//不要这样!这样会创建一个包含 2 或 3 项的数组</span></span><br><span class="line"><span class="keyword">var</span> options = [,,,,,]; <span class="comment">//不要这样!这样会创建一个包含 5 或 6 项的数组</span></span><br></pre></td></tr></table></figure>
<p>在读取和设置数组的值时，要使用方括号并提供相应值的基于 0 的数字索引，如下所示:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">alert(colors[<span class="number">0</span>]); <span class="comment">//显示第一项</span></span><br><span class="line">colors[<span class="number">2</span>] = <span class="string">"black"</span>; <span class="comment">//修改第三项</span></span><br><span class="line">colors[<span class="number">3</span>] = <span class="string">"brown"</span>; <span class="comment">//新增第四项</span></span><br></pre></td></tr></table></figure>
<p>如果设置某个值的索引<strong>超过</strong>了数组现有项数，如这个例子中的 <code>colors[3]</code> 所示，数组就会<strong>自动增加</strong>到该索引值加 1 的长度(就这个例子而言，索引是 3，因此数组长度就是 4)。</p>
<p>数组的项数保存在其 <code>length</code> 属性中，这个属性始终会返回 <code>0</code> 或更大的值。<strong>数组</strong>的 <code>length</code> 属性<strong>不是只读</strong>的。因此，通过设置这个属性，可以<strong>从数组的末尾移除项</strong>或<strong>向数组中添加新项</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">colors.length = <span class="number">2</span>;</span><br><span class="line">alert(colors[<span class="number">2</span>]); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">colors.length = <span class="number">4</span>;</span><br><span class="line">alert(colors[<span class="number">3</span>]); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<p><strong>在数组末尾添加新项</strong>，如下所示:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]; <span class="comment">//创建一个包含 3 个字符串的数组</span></span><br><span class="line">colors[colors.length] = <span class="string">"black"</span>; <span class="comment">//(在位置3)添加一种颜色</span></span><br><span class="line">colors[colors.length] = <span class="string">"brown"</span>; <span class="comment">//(在位置4)再添加一种颜色</span></span><br></pre></td></tr></table></figure>
<p>当把一个值放在<strong>超出当前数组大小</strong>的位置上时，数组就会<strong>重新计算</strong>其长度值，即长度值等于<strong>最后一项的索引加 1</strong>，如下所示:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]; <span class="comment">//创建一个包含 3 个字符串的数组</span></span><br><span class="line">colors[<span class="number">99</span>] = <span class="string">"black"</span>; <span class="comment">//(在位置 99)添加一种颜色</span></span><br><span class="line">alert(colors.length); <span class="comment">//100</span></span><br><span class="line"><span class="comment">//位置 3 到位置 98 实际上都是不存在的，所以访问它们都将返回 undefined。</span></span><br></pre></td></tr></table></figure>
<h3 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h3><h4 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray()"></a>Array.isArray()</h4><p>对于一个网页，或者一个<strong>全局作用域</strong>而言，使用 <code>instanceof</code> 操作符就能得到满意的结果:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Array</span>) &#123;</span><br><span class="line">  <span class="comment">//对数组执行某些操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>instanceof</code> 操作符的问题在于，它假定<strong>只有一个</strong>全局执行环境。如果网页中<strong>包含多个框架</strong>，那实际上就存在<strong>两个以上不同的全局执行环境</strong>，从而存在两个以上<strong>不同版本</strong>的 <code>Array</code> 构造函数。如果你从一个框架向另一个框架传入一个数组，那么<strong>传入</strong>的数组与在第二个框架中<strong>原生</strong>创建的数组分别具有<strong>各自不同</strong>的构造函数。</p>
<p>为了解决这个问题可以使用 <code>Array.isArray()</code> 方法。这个方法的目的是<strong>最终确定某个值到底是不是数组</strong>，而不管它是在哪个全局执行环境中创建的。这个方法的用法如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">  <span class="comment">//对数组执行某些操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="转换方法"><a href="#转换方法" class="headerlink" title="转换方法"></a>转换方法</h3><h4 id="toLocaleString-、toString-和-valueOf"><a href="#toLocaleString-、toString-和-valueOf" class="headerlink" title="toLocaleString()、toString() 和 valueOf()"></a>toLocaleString()、toString() 和 valueOf()</h4><p><strong>所有</strong>对象都具有 <code>toLocaleString()</code>、<code>toString()</code> 和 <code>valueOf()</code> 方法。其中，调用<strong>数组</strong>的 <code>toString()</code> 方法会返回由数组中每个值的<strong>字符串形式</strong>拼接而成的一个以逗号分隔的字符串。而调用 <code>valueOf()</code> 返回的还是<strong>数组</strong>。实际上，为了创建这个字符串会调用数组每一项的 <code>toString()</code> 方法。来看下面这个例子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]; <span class="comment">//创建一个包含 3 个字符串的数组</span></span><br><span class="line">alert(colors.toString()); <span class="comment">//red,blue,green</span></span><br><span class="line">alert(colors.valueOf()); <span class="comment">//red,blue,green</span></span><br><span class="line">alert(colors); <span class="comment">//red,blue,green</span></span><br></pre></td></tr></table></figure>
<p>在这里，我们首先显式地调用了 <code>toString()</code> 方法，以便返回数组的<strong>字符串表示</strong>，每个值的字符串表示拼接成了一个字符串，中间以逗号分隔。接着调用 <code>valueOf()</code> 方法，而最后一行代码直接将<strong>数组</strong>传递给了 <code>alert()</code>。由于 <code>alert()</code> 要接收字符串参数，所以它会在<strong>后台调用</strong> <code>toString()</code> 方法，由此会得到与直接调用 <code>toString()</code> 方法<strong>相同</strong>的结果。</p>
<p>另外，<code>toLocaleString()</code> 方法经常也会返回与 <code>toString()</code> 和 <code>valueOf()</code> 方法<strong>相同</strong>的值，但也<strong>不总是</strong>如此。当调用数组的 <code>toLocaleString()</code> 方法时，它也会创建一个数组值的以逗号分隔的<strong>字符串</strong>。而与前两个方法唯一的<strong>不同</strong>之处在于，这一次为了取得每一项的值，调用的是每一项的 <code>toLocaleString()</code> 方法，而不是 <code>toString()</code> 方法。请看下面这个例子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  toLocaleString : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Nikolaos"</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  toString : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Nicholas"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">  toLocaleString : <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Grigorios"</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  toString : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Greg"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> people = [person1, person2];</span><br><span class="line">alert(people); <span class="comment">//Nicholas,Greg</span></span><br><span class="line">alert(people.toString()); <span class="comment">//Nicholas,Greg</span></span><br><span class="line">alert(people.toLocaleString()); <span class="comment">//Nikolaos,Grigorios</span></span><br></pre></td></tr></table></figure>
<p>在将数组传递给 <code>alert()</code> 时，输出结果是 <code>Nicholas,Greg</code>，因为调用了数组每一项的 <code>toString()</code> 方法（同样，这与下一行<strong>显式调用</strong> <code>toString()</code> 方法得到的结果<strong>相同</strong>）。而当调用数组的 <code>toLocaleString()</code> 方法时，输出结果是 <code>Nikolaos,Grigorios</code>，原因是调用了数组每一项的 <code>toLocaleString()</code> 方法。</p>
<h4 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h4><p>数组继承的 <code>toLocaleString()</code>、<code>toString()</code> 和 <code>valueOf()</code> 方法，在默认情况下都会以逗号分隔的字符串的形式返回数组项。而如果使用 <code>join()</code> 方法，则可以使用<strong>不同的分隔符</strong>来构建这个字符串。<code>join()</code> 方法只接收<strong>一个</strong>参数，即用作分隔符的字符串，然后返回<strong>包含所有数组项的字符串</strong>。看下面的例子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</span><br><span class="line">alert(colors.join(<span class="string">","</span>)); <span class="comment">//red,green,blue(重现了toString()方法的输出)</span></span><br><span class="line">alert(colors.join(<span class="string">"||"</span>)); <span class="comment">//red||green||blue</span></span><br></pre></td></tr></table></figure>
<p>如果不给 <code>join()</code> 方法传入任何值，或者给它传入 <code>undefined</code>，则使用<strong>逗号</strong>作为分隔符。</p>
<blockquote>
<p>如果数组中某一项的值是 <code>null</code> 或者 <code>undefined</code>，那么该值在 <code>join()</code>、<code>toLocaleString()</code>、<code>toString()</code>和 <code>valueOf()</code> 方法返回的结果中以<strong>空字符串</strong>表示。</p>
</blockquote>
<h3 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h3><h4 id="push-和-pop"><a href="#push-和-pop" class="headerlink" title="push() 和 pop()"></a>push() 和 pop()</h4><p>数组可以表现得就像<strong>栈</strong>一样，后者是一种可以<strong>限制插入和删除项</strong>的数据结构。栈是一种 <strong>LIFO(Last-In-First-Out，后进先出)</strong>的数据结构，也就是最新添加的项最早被移除。而栈中项的插入(叫做<strong>推入</strong>)和移除(叫做<strong>弹出</strong>)，只发生在一个位置——<strong>栈的顶部</strong>。数组有专门的 <code>push()</code> 和 <code>pop()</code> 方法，以便实现类似栈的行为。</p>
<p><code>push()</code> 方法可以接收<strong>任意数量</strong>的参数，把它们<strong>逐个添加到数组末尾</strong>，并<strong>返回修改后数组的长度</strong>。而 <code>pop()</code> 方法则<strong>从数组末尾移除最后一项</strong>，减少数组的 <code>length</code> 值，然后<strong>返回移除的项</strong>。请看下面的例子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(); <span class="comment">//创建一个数组</span></span><br><span class="line"><span class="keyword">var</span> count = colors.push(<span class="string">"red"</span>, <span class="string">"green"</span>); <span class="comment">//推入两项</span></span><br><span class="line">alert(count); <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">count = colors.push(<span class="string">"black"</span>); <span class="comment">//推入另一项</span></span><br><span class="line">alert(count); <span class="comment">//3</span></span><br><span class="line"><span class="comment">//此时数组中各项顺序为"red"、"green"、"black"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> item = colors.pop(); <span class="comment">//取得最后一项</span></span><br><span class="line">alert(item); <span class="comment">//"black"</span></span><br><span class="line">alert(colors.length); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p>可以将<strong>栈方法</strong>与<strong>其他数组方法</strong>连用，像下面这个例子一样:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>];</span><br><span class="line">colors.push(<span class="string">"brown"</span>); <span class="comment">//添加另一项</span></span><br><span class="line">colors[<span class="number">3</span>] = <span class="string">"black"</span>; <span class="comment">//添加一项</span></span><br><span class="line">alert(colors.length); <span class="comment">//4</span></span><br><span class="line"><span class="comment">//此时数组中各项顺序为"red"、"blue"、"brown"、"black"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> item = colors.pop(); <span class="comment">//取得最后一项</span></span><br><span class="line">alert(item); <span class="comment">//"black"</span></span><br></pre></td></tr></table></figure>
<h3 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h3><h4 id="shift"><a href="#shift" class="headerlink" title="shift()"></a>shift()</h4><p><strong>队列</strong>数据结构的访问规则是 <strong>FIFO(First-In-First-Out，先进先出)</strong>。队列在列表的<strong>末端添加项</strong>，从列表的<strong>前端移除项</strong>。由于 <code>push()</code> 是向数组<strong>末端添加项</strong>的方法， 因此要模拟队列只需一个从数组<strong>前端取得项</strong>的方法。实现这一操作的数组方法就是 <code>shift()</code>，它能够<strong>移除数组中的第一个项并返回该项</strong>，同时将<strong>数组长度减 1</strong>。结合使用 <code>shift()</code> 和 <code>push()</code> 方法，可以像使用<strong>队列</strong>一样使用数组:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(); <span class="comment">//创建一个数组</span></span><br><span class="line"><span class="keyword">var</span> count = colors.push(<span class="string">"red"</span>, <span class="string">"green"</span>); <span class="comment">//推入两项</span></span><br><span class="line">alert(count); <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">count = colors.push(<span class="string">"black"</span>); <span class="comment">//推入另一项</span></span><br><span class="line">alert(count); <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> item = colors.shift(); <span class="comment">//取得第一项</span></span><br><span class="line">alert(item); <span class="comment">//"red"</span></span><br><span class="line">alert(colors.length); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<h4 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h4><p><code>unshift()</code> 与 <code>shift()</code> 的用途<strong>相反</strong>: 它能<strong>在数组前端添加任意个项并返回新数组的长度</strong>。因此，同时使用 <code>unshift()</code> 和 <code>pop()</code> 方法，可以<strong>从相反的方向</strong>来<strong>模拟队列</strong>，即在数组的<strong>前端添加项</strong>，从数组<strong>末端移除项</strong>，如下面的例子所示:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(); <span class="comment">//创建一个数组</span></span><br><span class="line"><span class="keyword">var</span> count = colors.unshift(<span class="string">"red"</span>, <span class="string">"green"</span>); <span class="comment">//推入两项</span></span><br><span class="line">alert(count); <span class="comment">//2</span></span><br><span class="line"><span class="comment">//此时数组中各项顺序为"red"、"green"</span></span><br><span class="line"></span><br><span class="line">count = colors.unshift(<span class="string">"black"</span>); <span class="comment">//推入另一项</span></span><br><span class="line">alert(count); <span class="comment">//3</span></span><br><span class="line"><span class="comment">//此时数组中各项顺序为"black"、"red"、"green"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> item = colors.pop(); <span class="comment">//取得最后一项</span></span><br><span class="line">alert(item); <span class="comment">//"green"</span></span><br><span class="line">alert(colors.length); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<h3 id="重排序方法"><a href="#重排序方法" class="headerlink" title="重排序方法"></a>重排序方法</h3><p>数组中已经存在<strong>两个</strong>可以<strong>直接</strong>用来<strong>重排序</strong>的方法: <code>reverse()</code> 和 <code>sort()</code>。</p>
<h4 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h4><p><code>reverse()</code> 方法会<strong>反转</strong>数组项的顺序。如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">values.reverse();</span><br><span class="line">alert(values); <span class="comment">//5,4,3,2,1</span></span><br></pre></td></tr></table></figure>
<h4 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h4><p>在默认情况下，<code>sort()</code> 方法按<strong>升序</strong>排列数组项——即最小的值位于最前面，最大的值排在最后面。 为了实现排序，<code>sort()</code> 方法会调用每个数组项的 <code>toString()</code> 转型方法，然后比较得到的<strong>字符串</strong>，以确定如何排序。即使数组中的每一项都是数值，<code>sort()</code> 方法比较的也是<strong>字符串</strong>，如下所示:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.sort();</span><br><span class="line">alert(values); <span class="comment">//0,1,10,15,5</span></span><br></pre></td></tr></table></figure>
<p>数值 <code>5</code> 虽然小于 <code>10</code>，但在进行字符串比较时，<code>&quot;10&quot;</code> 则位于 <code>&quot;5&quot;</code> 的前面，于是数组的顺序就被修改了。 不用说，这种排序方式在很多情况下都<strong>不是</strong>最佳方案。因此 <code>sort()</code> 方法可以<strong>接收一个比较函数作为参数</strong>，以便我们<strong>指定</strong>哪个值位于哪个值的前面。</p>
<p>比较函数接收<strong>两个</strong>参数，如果第一个参数应该位于第二个<strong>之前</strong>则返回一个<strong>负数</strong>，如果两个参数<strong>相等</strong>则返回 <code>0</code>，如果第一个参数应该位于第二个<strong>之后</strong>则返回一个<strong>正数</strong>。以下就是一个简单的比较函数:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回值大于0则交换两个变量的位置</span></span><br><span class="line"><span class="comment">//返回值小于0则维持现状</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.sort(compare);</span><br><span class="line">alert(values); <span class="comment">//0,1,5,10,15</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>看返回负值时从左到右两个变量的大小关系，确定升序降序。</p>
</blockquote>
<p>将比较函数传递到 <code>sort()</code> 方法之后，数值仍然保持了正确的<strong>升序</strong>。也可以通过比较函数产生<strong>降序</strong>排序的结果，只要<strong>交换</strong>比较函数<strong>返回的值</strong>即可。</p>
<blockquote>
<p><code>reverse()</code> 和 <code>sort()</code> 方法的<strong>返回值是经过排序之后的数组</strong>。</p>
</blockquote>
<p>对于<strong>数值类型</strong>或者其 <code>valueOf()</code> 方法会<strong>返回数值类型</strong>的对象类型，可以使用一个<strong>更简单</strong>的比较函数。这个函数只要<strong>用第二个值减第一个值</strong>即可:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value2 - value1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//降序排列</span></span><br></pre></td></tr></table></figure>
<h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><h4 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h4><p><code>concat()</code> 方法可以<strong>基于当前数组中的所有项创建一个新数组</strong>。具体来说，这个方法会先创建<strong>当前数组的一个副本</strong>，然后将接收到的参数<strong>添加到这个副本的末尾</strong>，最后<strong>返回新构建的数组</strong>。在<strong>没有</strong>给 <code>concat()</code> 方法传递参数的情况下，它只是复制当前数组并返回副本。如果传递给 <code>concat()</code> 方法的是<strong>一或多个数组</strong>，则该方法会将这些<strong>数组中的每一项</strong>都添加到结果数组中。如果传递的值<strong>不是数组</strong>，这些值就会被<strong>简单地添加</strong>到结果数组的末尾。下面来看一个例子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</span><br><span class="line"><span class="keyword">var</span> colors2 = colors.concat(<span class="string">"yellow"</span>, [<span class="string">"black"</span>, <span class="string">"brown"</span>]);</span><br><span class="line"></span><br><span class="line">alert(colors); <span class="comment">//red,green,blue</span></span><br><span class="line">alert(colors2); <span class="comment">//red,green,blue,yellow,black,brown</span></span><br></pre></td></tr></table></figure>
<h4 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h4><p><code>slice()</code> 能够基于<strong>当前数组中的一或多个项创建一个新数组</strong>。<code>slice()</code> 方法可以接受<strong>一或两个参数</strong>，即要返回项的<strong>起始</strong>和<strong>结束</strong>位置。在<strong>只有一个参数的情况下</strong>，<code>slice()</code> 方法返回从该参数<strong>指定位置开始到当前数组末尾的所有项</strong>。如果<strong>有两个参数</strong>，该方法返回<strong>起始和结束位置之间的项—</strong>—但<strong>不包括</strong>结束位置的项。注意，<code>slice()</code> 方法<strong>不会</strong>影响原始数组。请看下面的例子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>, <span class="string">"yellow"</span>, <span class="string">"purple"</span>];</span><br><span class="line"><span class="keyword">var</span> colors2 = colors.slice(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> colors3 = colors.slice(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">alert(colors2); <span class="comment">//green,blue,yellow,purple</span></span><br><span class="line">alert(colors3); <span class="comment">//green,blue,yellow</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果 <code>slice()</code> 方法的参数中有一个<strong>负数</strong>，则用<strong>数组长度加上该数来确定相应的位 置</strong>。例如，在一个包含 5 项的数组上调用 <code>slice(-2,-1)</code> 与调用 <code>slice(3,4)</code> 得到的结果相同。如果结束位置<strong>小于</strong>起始位置，则返回<strong>空数组</strong>。</p>
</blockquote>
<h4 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h4><p><code>splice()</code> 方法算是<strong>最强大的</strong>数组方法了，它有很多种用法。<code>splice()</code> 的主要用途是<strong>向数组的中部插入项</strong>，使用这种方法的方式则有如下 3 种:</p>
<ul>
<li><p><strong>删除: </strong>可以删除任意数量的项，只需指定 2 个参数——要删除的<strong>第一项的位置</strong>和要删除的<strong>项数</strong>。例如，<code>splice(0,2)</code> 会删除数组中的前两项。</p>
</li>
<li><p><strong>插入: </strong>可以向指定位置插入任意数量的项，只需提供 3 个参数: <strong>起始位置</strong>、<strong>0（要删除的项数）</strong>和<strong>要插入的项</strong>。如果要插入多个项，可以再传入第四、第五，以至任意多个项。例如，<code>splice(2,0,&quot;red&quot;,&quot;green&quot;)</code> 会从当前数组的位置 2 开始插入字符串 <code>&quot;red&quot;</code> 和 <code>&quot;green&quot;</code>。</p>
</li>
<li><p><strong>替换: </strong>可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数: <strong>起始位置</strong>、<strong>要删除的项数</strong>和<strong>要插入的任意数量的项</strong>。插入的项数不必与删除的项数相等。例如，<code>splice(2,1,&quot;red&quot;,&quot;green&quot;)</code> 会删除当前数组位置 2 的项，然后再从位置 2 开始插入字符串 <code>&quot;red&quot;</code> 和 <code>&quot;green&quot;</code>。</p>
</li>
</ul>
<p><code>splice()</code> 方法始终都会<strong>返回一个数组</strong>，该数组中包含<strong>从原始数组中删除的项</strong>(如果没有删除任何项，则返回一个空数组)。下面的代码展示了上述 3 种使用 <code>splice()</code> 方法的方式:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除第一项</span></span><br><span class="line"><span class="keyword">var</span> removed = colors.splice(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">alert(colors); <span class="comment">//green,blue</span></span><br><span class="line">alert(removed); <span class="comment">//red，返回的数组中只包含一项</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从位置 1 开始插入两项</span></span><br><span class="line">removed = colors.splice(<span class="number">1</span>, <span class="number">0</span>, <span class="string">"yellow"</span>, <span class="string">"orange"</span>);</span><br><span class="line">alert(colors); <span class="comment">//green,yellow,orange,blue</span></span><br><span class="line">alert(removed); <span class="comment">//返回的是一个空数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入两项，删除一项</span></span><br><span class="line">removed = colors.splice(<span class="number">1</span>, <span class="number">1</span>, <span class="string">"red"</span>, <span class="string">"purple"</span>);</span><br><span class="line">alert(colors); <span class="comment">//green,red,purple,orange,blue</span></span><br><span class="line">alert(removed); <span class="comment">//yellow，返回的数组中只包含一项</span></span><br></pre></td></tr></table></figure>
<h3 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h3><h4 id="indexOf-和-lastIndexOf"><a href="#indexOf-和-lastIndexOf" class="headerlink" title="indexOf() 和 lastIndexOf()"></a>indexOf() 和 lastIndexOf()</h4><p>2 个<strong>位置方法</strong>: <code>indexOf()</code> 和 <code>lastIndexOf()</code>。这两个方法都接收两个参数: <strong>要查找的项</strong>和<strong>(可选的)表示查找起点位置的索引</strong>。其中，<code>indexOf()</code> 方法从数组的<strong>开头(位置 0)开始</strong>向后查找，<code>lastIndexOf()</code> 方法则从数组的<strong>末尾开始</strong>向前查找。</p>
<p>这两个方法都返回<strong>要查找的项在数组中的位置</strong>，或者在没找到的情况下返回 <code>-1</code>。在比较第一个参数与数组中的每一项时，会使用<strong>全等操作符</strong>；也就是说，要求查找的项必须<strong>严格相等</strong>(就像使用 <code>===</code> 一样)。以下是几个例子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">alert(numbers.indexOf(<span class="number">4</span>)); <span class="comment">//3</span></span><br><span class="line">alert(numbers.lastIndexOf(<span class="number">4</span>)); <span class="comment">//5</span></span><br><span class="line"></span><br><span class="line">alert(numbers.indexOf(<span class="number">4</span>, <span class="number">4</span>)); <span class="comment">//5</span></span><br><span class="line">alert(numbers.lastIndexOf(<span class="number">4</span>, <span class="number">4</span>)); <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123; <span class="attr">name</span>: <span class="string">"Nicholas"</span> &#125;;</span><br><span class="line"><span class="keyword">var</span> people = [&#123; <span class="attr">name</span>: <span class="string">"Nicholas"</span> &#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> morePeople = [person];</span><br><span class="line"></span><br><span class="line">alert(people.indexOf(person)); <span class="comment">//-1</span></span><br><span class="line">alert(morePeople.indexOf(person)); <span class="comment">//0</span></span><br></pre></td></tr></table></figure>
<h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3><p>5 个迭代方法。每个方法都接收两个参数: <strong>要在每一项上运行的函数</strong>和<strong>（可选的）运行该函数的作用域对象</strong>——影响 <code>this</code> 的值。传入这些方法中的函数会接收三个参数: <strong>数组项的值</strong>、<strong>该项在数组中的位置</strong>和<strong>数组对象本身</strong>。根据使用的方法不同，这个函数执行后的返回值<strong>可能会</strong>也<strong>可能不会</strong>影响方法的返回值。以下是这 5 个迭代方法的作用:</p>
<ul>
<li><code>every()</code>: 对数组中的每一项运行给定函数，如果该函数对<strong>每一项</strong>都返回 <code>true</code>，则返回 <code>true</code>。</li>
<li><code>filter()</code>: 对数组中的每一项运行给定函数，返回<strong>该函数会返回 <code>true</code> 的项组成的数组</strong>。</li>
<li><code>forEach()</code>: 对数组中的每一项运行给定函数。这个方法<strong>没有返回值</strong>。</li>
<li><code>map()</code>: 对数组中的每一项运行给定函数，返回<strong>每次函数调用的结果组成的数组</strong>。</li>
<li><code>some()</code>: 对数组中的每一项运行给定函数，如果该函数对<strong>任一项</strong>返回 <code>true</code>，则返回 <code>true</code>。</li>
</ul>
<p>以上方法都<strong>不会</strong>修改数组中的包含的值。</p>
<h4 id="every-和-some"><a href="#every-和-some" class="headerlink" title="every() 和 some()"></a>every() 和 some()</h4><p>示例如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> everyResult = numbers.every(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (item &gt; <span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line">alert(everyResult); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> someResult = numbers.some(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (item &gt; <span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line">alert(someResult); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h4 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h4><p><code>filter()</code> 利用指定的函数确定<strong>是否在返回的数组中包含某一项</strong>。这个方法对<strong>查询符合某些条件的所有数组项</strong>非常有用。例如，要返回一个所有数值都大于 2 的数组，可以使用以下代码:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> filterResult = numbers.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (item &gt; <span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line">alert(filterResult); <span class="comment">//[3,4,5,4,3]</span></span><br></pre></td></tr></table></figure>
<h4 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h4><p><code>map()</code> 也返回一个数组，而这个数组的<strong>每一项都是在原始数组中的对应项上运行传入函数的结果</strong>。这个方法适合<strong>创建包含的项与另一个数组一一对应的数组</strong>。例如，可以给数组中的每一项乘以 2，然后返回这些乘积组成的数组，如下所示:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> mapResult = numbers.map(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line">alert(mapResult); <span class="comment">//[2,4,6,8,10,8,6,4,2]</span></span><br></pre></td></tr></table></figure>
<h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h4><p><code>forEach()</code> 只是<strong>对数组中的每一项运行传入的函数</strong>。这个方法<strong>没有返回值</strong>，本质上<strong>与使用 <code>for</code> 循环迭代数组一样</strong>。例子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>];</span><br><span class="line">numbers.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//执行某些操作</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h3><p>两个归并数组的方法: <code>reduce()</code> 和 <code>reduceRight()</code>。这两个方法都会迭代数组的所有项，然后构建一个最终返回的值。其中，<code>reduce()</code> 方法从数组的<strong>第一项</strong>开始，逐个<strong>遍历到最后</strong>。而 <code>reduceRight()</code> 则从数组的<strong>最后一项</strong>开始，向前<strong>遍历到第一项</strong>。</p>
<p>这两个方法都接收两个参数: 一个<strong>在每一项上调用的函数</strong>和<strong>(可选的)作为归并基础的初始值</strong>。传给 <code>reduce()</code> 和 <code>reduceRight()</code> 的函数接收 4 个参数: <strong>前一个值、当前值、项的索引和数组对象</strong>。这个函数<strong>返回的任何值都会作为第一个参数自动传给下一项</strong>。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。</p>
<h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h4><p>使用 <code>reduce()</code> 方法可以执行<strong>求数组中所有值之和</strong>的操作，比如:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> sum = values.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> prev + cur;</span><br><span class="line">&#125;);</span><br><span class="line">alert(sum); <span class="comment">//15</span></span><br></pre></td></tr></table></figure>
<p>第一次执行回调函数，<code>prev</code> 是 <code>1</code>，<code>cur</code> 是 <code>2</code>。第二次，<code>prev</code> 是 <code>3</code>(1 加 2 的结果)，<code>cur</code> 是 <code>3</code>(数组的第三项)。这个过程会持续到把数组中的<strong>每一项</strong>都访问一遍，最后<strong>返回结果</strong>。</p>
<h4 id="reduceRight"><a href="#reduceRight" class="headerlink" title="reduceRight()"></a>reduceRight()</h4><p><code>reduceRight()</code> 的作用<strong>类似</strong>，只不过<strong>方向相反</strong>而已。来看下面这个例子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> sum = values.reduceRight(<span class="function"><span class="keyword">function</span>(<span class="params">prev, cur, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> prev + cur;</span><br><span class="line">&#125;);</span><br><span class="line">alert(sum); <span class="comment">//15</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，第一次执行回调函数，<code>prev</code> 是 <code>5</code>，<code>cur</code> 是 <code>4</code>。当然，最终结果<strong>相同</strong>，因为执行的都是简单相加的操作。</p>
<h2 id="Function类型"><a href="#Function类型" class="headerlink" title="Function类型"></a>Function类型</h2><p>函数<strong>实际上是对象</strong>。每个函数都是 <code>Function</code> 类型的实例，而且都与其他引用类型一样具有<strong>属性</strong>和<strong>方法</strong>。由于函数是对象，因此函数名实际上也是一个<strong>指向函数对象的指针</strong>，<strong>不会</strong>与某个函数<strong>绑定</strong>。函数通常是使用<strong>函数声明</strong>语法定义的，如下面的例子所示:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这与下面使用<strong>函数表达式</strong>定义函数的方式几乎一样:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最后一种定义函数的方式是使用 <code>Function</code> <strong>构造函数</strong>。<code>Function</code> 构造函数可以接收<strong>任意数量的参数</strong>， 但<strong>最后一个</strong>参数始终都被看成是<strong>函数体</strong>，而前面的参数则枚举出了<strong>新函数的参数</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"num1"</span>, <span class="string">"num2"</span>, <span class="string">"return num1 + num2"</span>); <span class="comment">//不推荐</span></span><br></pre></td></tr></table></figure>
<p>这种语法会导致<strong>解析两次</strong>代码(第一次是解析常规代码，第二次是解析传入构造函数中的字符串)，从而<strong>影响性能</strong>。</p>
<p>由于函数名仅仅是指向函数的<strong>指针</strong>，因此函数名与包含对象指针的其他变量没有什么不同。换句话说，一个函数可能会有<strong>多个名字</strong>，如下面的例子所示:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">alert(sum(<span class="number">10</span>,<span class="number">10</span>));        <span class="comment">//20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherSum = sum;</span><br><span class="line">alert(anotherSum(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">//20</span></span><br><span class="line"></span><br><span class="line">sum = <span class="literal">null</span>;</span><br><span class="line">alert(anotherSum(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">//20</span></span><br></pre></td></tr></table></figure>
<h3 id="没有重载"><a href="#没有重载" class="headerlink" title="没有重载"></a>没有重载</h3><p>将函数名想象为<strong>指针</strong>，这有助于理解为什么 JavaScript 中<strong>没有函数重载</strong>的概念。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addSomeNumber</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num + <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addSomeNumber</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num + <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = addSomeNumber(<span class="number">100</span>); <span class="comment">//300</span></span><br></pre></td></tr></table></figure>
<p>这个例子中声明了两个同名函数，而结果则是<strong>后面的函数覆盖了前面的函数</strong>。以上代码实际上与下面的代码<strong>没有</strong>什么区别。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addSomeNumber = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num + <span class="number">100</span>;</span><br><span class="line">&#125;;</span><br><span class="line">addSomeNumber = <span class="function"><span class="keyword">function</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num + <span class="number">200</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> result = addSomeNumber(<span class="number">100</span>); <span class="comment">//300</span></span><br></pre></td></tr></table></figure>
<p>通过观察<strong>重写之后</strong>的代码，可以看出在创建<strong>第二个</strong>函数时，实际上<strong>覆盖</strong>了引用<strong>第一个</strong>函数的变量 <code>addSomeNumber</code>。</p>
<h3 id="函数声明与函数表达式"><a href="#函数声明与函数表达式" class="headerlink" title="函数声明与函数表达式"></a>函数声明与函数表达式</h3><p><strong>解析器</strong>在向执行环境中加载数据时，对函数声明和函数表达式<strong>并非</strong>一视同仁。解析器会<strong>率先读取函数声明</strong>，并使其在<strong>执行任何代码之前</strong>可用(可以访问)；至于<strong>函数表达式</strong>，则必须等到<strong>解析器执行到它所在的代码行</strong>，才会真正被解释执行。请看下面的例子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(sum(<span class="number">10</span>,<span class="number">10</span>));</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码完全可以<strong>正常运行</strong>。因为在代码开始<strong>执行之前</strong>，解析器就已经通过一个名为<strong>函数声明提升</strong>的过程，读取并将函数声明添加到执行环境中。对代码求值时，JavaScript 引擎在第一遍会声明函数并将它们放到源代码树的顶部。所以，即使声明函数的代码在调用它的代码<strong>后面</strong>，JavaScript 引擎也能把函数声明<strong>提升</strong>到顶部。如果把上面的函数声明改为等价的<strong>函数表达式</strong>，就会在执行期间导致<strong>错误</strong>。</p>
<blockquote>
<p>除了什么时候可以通过变量访问函数这<strong>一点</strong>区别之外，函数声明与函数表达式的语法其实是<strong>等价</strong>的。</p>
</blockquote>
<h3 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h3><p>因为函数名本身就是<strong>变量</strong>，所以函数也可以<strong>作为值</strong>来使用。也就是说，不仅可以像传递参数一样把一个函数<strong>传递给另一个函数</strong>，而且可以将一个函数<strong>作为另一个函数的结果返回</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSomeFunction</span>(<span class="params">someFunction, someArgument</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> someFunction(someArgument);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数接受两个参数。第一个参数应该是一个函数，第二个参数应该是要传递给该函数的一个值。然后，就可以像下面的例子一样传递函数了:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add10</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num + <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result1 = callSomeFunction(add10, <span class="number">10</span>);</span><br><span class="line">alert(result1);   <span class="comment">//20</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getGreeting</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Hello, "</span> + name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result2 = callSomeFunction(getGreeting, <span class="string">"Nicholas"</span>);</span><br><span class="line">alert(result2); <span class="comment">//"Hello, Nicholas"</span></span><br></pre></td></tr></table></figure>
<p>这里的 <code>callSomeFunction()</code> 函数是<strong>通用的</strong>，即无论第一个参数中传递进来的是什么函数，它都会返回<strong>执行第一个参数后</strong>的结果。</p>
<p>要<strong>访问</strong>函数的指针而<strong>不执行</strong>函数的话，必须<strong>去掉</strong>函数名后面的那对<strong>圆括号</strong>。因此上面例子中传递给 <code>callSomeFunction()</code> 的是 <code>add10</code> 和 <code>getGreeting</code>，而<strong>不是</strong>执行它们之后的结果。</p>
<p>可以从一个函数中<strong>返回</strong>另一个函数，而且这也是极为有用的一种技术。例如，假设有一个 对象数组，我们想要根据某个对象属性对数组进行<strong>排序</strong>。而传递给数组 <code>sort()</code> 方法的比较函数要接收两个参数，即要比较的值。可是，我们需要一种方式来指明按照哪个属性来排序。要解决这个问题，可以定义一个函数，它接收一个属性名，然后根据这个属性名来创建一个比较函数，下面就是这个函数的定义:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">object1, object2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value1 = object1[propertyName];</span><br><span class="line">    <span class="keyword">var</span> value2 = object2[propertyName];</span><br><span class="line">    <span class="keyword">if</span> (value1 &lt; value2) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的函数可以在像下面这样的函数中这样使用:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [&#123;<span class="attr">name</span>: <span class="string">"Zachary"</span>, <span class="attr">age</span>: <span class="number">28</span>&#125;, &#123;<span class="attr">name</span>: <span class="string">"Nicholas"</span>, <span class="attr">age</span>: <span class="number">29</span>&#125;];</span><br><span class="line"></span><br><span class="line">data.sort(createComparisonFunction(<span class="string">"name"</span>));</span><br><span class="line">alert(data[<span class="number">0</span>].name);  <span class="comment">//Nicholas</span></span><br><span class="line"></span><br><span class="line">data.sort(createComparisonFunction(<span class="string">"age"</span>));</span><br><span class="line">alert(data[<span class="number">0</span>].name);  <span class="comment">//Zachary</span></span><br></pre></td></tr></table></figure>
<h3 id="函数内部属性"><a href="#函数内部属性" class="headerlink" title="函数内部属性"></a>函数内部属性</h3><h4 id="arguments-对象"><a href="#arguments-对象" class="headerlink" title="arguments 对象"></a>arguments 对象</h4><p><code>arguments</code>是一个<strong>类数组</strong>对象，包含着传入函数中的所有参数。虽然 <code>arguments</code> 的主要用途是保存函数参数， 但这个对象还有一个名叫 <code>callee</code> 的属性，该属性是一个<strong>指针</strong>，指向拥有这个 <code>arguments</code> 对象的函数。请看下面这个非常经典的阶乘函数:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (num &lt;=<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num * factorial(num<span class="number">-1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义阶乘函数一般都要用到<strong>递归算法</strong>。如上面的代码所示，在函数<strong>有名字</strong>，而且名字以后也<strong>不会变</strong>的情况下，这样定义没有问题。但问题是这个函数的执行与函数名 <code>factorial</code> 紧紧耦合在了一起。为了消除这种紧密耦合的现象，可以像下面这样使用 <code>arguments.callee</code>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (num &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> num * <span class="built_in">arguments</span>.callee(num - <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个重写后的 <code>factorial()</code> 函数的函数体内，没有再引用函数名 <code>factorial</code>。这样，<strong>无论</strong>引用函数时使用的是什么名字，都可以保证正常完成递归调用。例如:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> trueFactorial = factorial;</span><br><span class="line">  factorial = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line">alert(trueFactorial(<span class="number">5</span>)); <span class="comment">//120</span></span><br><span class="line">alert(factorial(<span class="number">5</span>)); <span class="comment">//0</span></span><br></pre></td></tr></table></figure>
<p>变量 <code>trueFactorial</code> 获得了 <code>factorial</code> 的值，实际上是在另一个位置上保存了一个函数的指针。然后，我们又将一个简单地返回 <code>0</code> 的函数赋值给 <code>factorial</code> 变量。如果像原来的 <code>factorial()</code> 那样不使用 <code>arguments.callee</code>，调用 <code>trueFactorial()</code>就会返回 <code>0</code>。可是，在解除了函数体内的代码与函数名的耦合状态之后，<code>trueFactorial()</code> 仍然能够正常地计算阶乘；至于 <code>factorial()</code>，它现在只是一个返回 <code>0</code> 的函数。</p>
<h3 id="this-对象"><a href="#this-对象" class="headerlink" title="this 对象"></a>this 对象</h3><p><code>this</code> 的行为与 Java 和 C#中的 <code>this</code> 大致类似。换句话说，<code>this</code> 引用的是<strong>函数据以执行的</strong>环境对象——或者也可以说是 <code>this</code> 值(当在网页的全局作用域中调用函数时， <code>this</code> 对象引用的就是 window)。来看下面的例子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  color: <span class="string">"blue"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayColor(); <span class="comment">//"red"</span></span><br><span class="line">o.sayColor = sayColor;</span><br><span class="line">o.sayColor(); <span class="comment">//"blue"</span></span><br></pre></td></tr></table></figure>
<h3 id="caller"><a href="#caller" class="headerlink" title="caller"></a>caller</h3><p>这个属性中保存着调用当前函数的函数的引用， 如果是在全局作用域中调用当前函数，它的值为 <code>null</code>。例如:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  inner();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(inner.caller);</span><br><span class="line">&#125;</span><br><span class="line">outer();</span><br></pre></td></tr></table></figure>
<p>以上代码会导致警告框中显示 <code>outer()</code> 函数的源代码。因为 <code>outer()</code> 调用了<code>inter()</code>，所以 <code>inner.caller</code> 就指向 <code>outer()</code>。为了实现更松散的耦合，也可以通过<code>arguments.callee.caller</code> 来访问相同的信息:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  inner();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="built_in">arguments</span>.callee.caller);</span><br><span class="line">&#125;</span><br><span class="line">outer();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当函数在<strong>严格模式</strong>下运行时，访问 <code>arguments.callee</code> 会导致错误。ECMAScript 5 还定义了 <code>arguments.caller</code> 属性，但在严格模式下访问它<strong>也会</strong>导致错误，而在非严格模式下这个属性始终是 <code>undefined</code>。定义这个属性是为了分清 <code>arguments.caller</code>和函数的 <code>caller</code> 属性。以上变化都是为了加强这门语言的安全性，这样第三方代码就不能在相同的环境里窥视其他代码了。</p>
</blockquote>
<h3 id="函数属性和方法"><a href="#函数属性和方法" class="headerlink" title="函数属性和方法"></a>函数属性和方法</h3><h4 id="length"><a href="#length" class="headerlink" title="length"></a>length</h4><p><code>length</code> 属性表示函数<strong>希望接收的</strong>命名参数的个数，如下面的例子所示:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  alert(name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">"hi"</span>);</span><br><span class="line">&#125;</span><br><span class="line">alert(sayName.length); <span class="comment">//1</span></span><br><span class="line">alert(sum.length); <span class="comment">//2</span></span><br><span class="line">alert(sayHi.length); <span class="comment">//0</span></span><br></pre></td></tr></table></figure>
<h4 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h4><p>对于<strong>引用类型</strong>而言，<code>prototype</code> 是保存它们<strong>所有实例方法</strong>的真正所在。换句话说，诸如 <code>toString()</code> 和 <code>valueOf()</code> 等方法实际上都保存在 <code>prototype</code> 名下，只不过是通过各自对象的实例访问罢了。在创建<strong>自定义引用类型</strong>以及实现<strong>继承</strong>时，<code>prototype</code> 属性的作用是<strong>极为重要</strong>的。<code>prototype</code> 属性是不可枚举的，因此使用 <code>for-in</code> 无法发现。</p>
<h4 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h4><p>每个函数都包含两个<strong>非继承而来</strong>的方法: <code>apply()</code>和 <code>call()</code>。这两个方法的用途都是在特定的作用域中调用函数，实际上等于<strong>设置函数体内 <code>this</code> 对象的值</strong>。首先，<code>apply()</code> 方法接收两个参数: 一个是在其中运行函数的<strong>作用域</strong>，另一个是<strong>参数数组</strong>。其中，第二个参数可以是 <code>Array</code> 的实例，也可以是 <code>arguments</code> 对象。例如:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum1</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sum.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); <span class="comment">//传入 arguments 对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum2</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sum.apply(<span class="keyword">this</span>, [num1, num2]); <span class="comment">//传入数组</span></span><br><span class="line">&#125;</span><br><span class="line">alert(callSum1(<span class="number">10</span>, <span class="number">10</span>)); <span class="comment">//20</span></span><br><span class="line">alert(callSum2(<span class="number">10</span>, <span class="number">10</span>)); <span class="comment">//20</span></span><br></pre></td></tr></table></figure>
<p>在上面这个例子中，<code>callSum1()</code> 在执行 <code>sum()</code> 函数时传入了 <code>this</code> 作为 <code>this</code> 值(因为是在<strong>全局作用域</strong>中调用的，所以传入的就是 <code>window</code> 对象)和 <code>arguments</code> 对象。而 <code>callSum2</code> 同样也调用了 <code>sum()</code> 函数，但它传入的则是 <code>this</code> 和一个参数数组。这两个函数<strong>都会</strong>正常执行并返回正确的结果。</p>
<h4 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h4><p><code>call()</code> 方法与 <code>apply()</code> 方法的<strong>作用相同</strong>，它们的区别仅在于<strong>接收参数的方式不同</strong>。对于 <code>call()</code> 方法而言，第一个参数是 <code>this</code> 值没有变化，变化的是其余参数都直接传递给函数。换句话说，在使用 <code>call()</code> 方法时，传递给函数的参数必须<strong>逐个列举</strong>出来，如下面的例子所示:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sum.call(<span class="keyword">this</span>, num1, num2);</span><br><span class="line">&#125;</span><br><span class="line">alert(callSum(<span class="number">10</span>, <span class="number">10</span>)); <span class="comment">//20</span></span><br></pre></td></tr></table></figure>
<p>在使用 <code>call()</code> 方法的情况下，<code>callSum()</code> 必须<strong>明确地传入每一个参数</strong>。结果与使用 <code>apply()</code> <strong>没有</strong>什么不同。至于是使用 <code>apply()</code> 还是 <code>call()</code>，完全取决于你采取哪种给函数传递参数的方式<strong>最方便</strong>。 如果你打算直接传入 <code>arguments</code> 对象，或者包含函数中先接收到的也是一个数组，那么使用 <code>apply()</code> 肯定更方便；否则，选择 <code>call()</code> 可能更合适。(在不给函数传递参数的情况下，使用哪个方法都无所谓。)</p>
<blockquote>
<p>在<strong>严格模式</strong>下，<strong>未</strong>指定环境对象而调用函数，则 <code>this</code> 值<strong>不会</strong>转型为 <code>window</code>。 除非<strong>明确</strong>把函数添加到某个对象或者调用 <code>apply()</code> 或 <code>call()</code>，否则 this 值将是 <code>undefined</code>。</p>
</blockquote>
<p>事实上，传递参数并非 <code>apply()</code> 和 <code>call()</code> 真正的用武之地；它们真正强大的地方是能够<strong>扩充函数赖以运行的作用域</strong>。下面来看一个例子:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  color: <span class="string">"blue"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line">sayColor(); <span class="comment">//red</span></span><br><span class="line">sayColor.call(<span class="keyword">this</span>); <span class="comment">//red</span></span><br><span class="line">sayColor.call(<span class="built_in">window</span>); <span class="comment">//red</span></span><br><span class="line">sayColor.call(o); <span class="comment">//blue</span></span><br></pre></td></tr></table></figure>
<p>这一次，<code>sayColor()</code> 也是作为<strong>全局函数</strong>定义的，而且当在全局作用域中调用它时，它确实会显示 <code>&quot;red&quot;</code>——因为对 <code>this.color</code> 的求值会转换成对 <code>window.color</code> 的求值。而 <code>sayColor.call(this)</code> 和 <code>sayColor.call(window)</code>，则是两种显式地在全局作用域中调用函数的方式，结果当然都会显示 <code>&quot;red&quot;</code>。但是，当运行 <code>sayColor.call(o)</code> 时，函数的执行环境就不一样了，因为此时函数体内的 <code>this</code> 对象指向了 <code>o</code>，于是结果显示的是 <code>&quot;blue&quot;</code>。</p>
<p>使用 <code>call()</code> 或 <code>apply()</code> 来扩充作用域的最大<strong>好处</strong>，就是对象<strong>不需要</strong>与方法有任何耦合关系。在前面例子的第一个版本中，我们是先将 <code>sayColor()</code> 函数放到了对象 <code>o</code> 中，然后再通过 <code>o</code> 来调用它的；而在这里重写的例子中，就<strong>不需要</strong>先前那个多余的步骤了。</p>
<h4 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h4><p><code>bind()</code> 方法会创建一个函数的实例，其 <code>this</code> 值会被绑定到传给 <code>bind()</code> 函数的值。例如:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  color: <span class="string">"blue"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> objectSayColor = sayColor.bind(o);</span><br><span class="line">objectSayColor(); <span class="comment">//blue</span></span><br></pre></td></tr></table></figure>
<p>在这里，<code>sayColor()</code> 调用 <code>bind()</code> 并传入对象 <code>o</code>，创建了 <code>objectSayColor()</code> 函数。<code>objectSayColor()</code> 函数的 <code>this</code> 值等于 <code>o</code>，因此即使是在全局作用域中调用这个函数，也会看到 <code>&quot;blue&quot;</code>。</p>
<p>每个函数继承的 <code>toLocaleString()</code> 和 <code>toString()</code> 方法始终都返回函数的代码。返回代码的格式则因浏览器而异——有的返回的代码与源代码中的函数代码一样，而有的则返回函数代码的内部表示，即由解析器删除了注释并对某些代码作了改动后的代码。由于存在这些差异，我们无法根据这两个方法返回的结果来实现任何重要功能；不过，这些信息在调试代码时倒是很有用。另外一个继承的 <code>valueOf()</code> 方法同样也只返回函数代码。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JavaScript/" rel="tag"># JavaScript</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/12/06/Ruby简单入门/" rel="next" title="Ruby 简单入门">
                <i class="fa fa-chevron-left"></i> Ruby 简单入门
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/12/10/JavaScript面向对象程序设计/" rel="prev" title="JavaScript 面向对象程序设计">
                JavaScript 面向对象程序设计 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
      <div id="sidebar-dimmer"></div>
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="http://p05mkbfri.bkt.clouddn.com/bye.jpg"
                alt="田丰" />
            
              <p class="site-author-name" itemprop="name">田丰</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Object-类型"><span class="nav-text">Object 类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Array-类型"><span class="nav-text">Array 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#检测数组"><span class="nav-text">检测数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Array-isArray"><span class="nav-text">Array.isArray()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#转换方法"><span class="nav-text">转换方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#toLocaleString-、toString-和-valueOf"><span class="nav-text">toLocaleString()、toString() 和 valueOf()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#join"><span class="nav-text">join()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#栈方法"><span class="nav-text">栈方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#push-和-pop"><span class="nav-text">push() 和 pop()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#队列方法"><span class="nav-text">队列方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#shift"><span class="nav-text">shift()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#unshift"><span class="nav-text">unshift()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重排序方法"><span class="nav-text">重排序方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#reverse"><span class="nav-text">reverse()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sort"><span class="nav-text">sort()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作方法"><span class="nav-text">操作方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#concat"><span class="nav-text">concat()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#slice"><span class="nav-text">slice()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#splice"><span class="nav-text">splice()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#位置方法"><span class="nav-text">位置方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#indexOf-和-lastIndexOf"><span class="nav-text">indexOf() 和 lastIndexOf()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#迭代方法"><span class="nav-text">迭代方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#every-和-some"><span class="nav-text">every() 和 some()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#filter"><span class="nav-text">filter()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#map"><span class="nav-text">map()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#forEach"><span class="nav-text">forEach()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#归并方法"><span class="nav-text">归并方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#reduce"><span class="nav-text">reduce()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#reduceRight"><span class="nav-text">reduceRight()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Function类型"><span class="nav-text">Function类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#没有重载"><span class="nav-text">没有重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数声明与函数表达式"><span class="nav-text">函数声明与函数表达式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#作为值的函数"><span class="nav-text">作为值的函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数内部属性"><span class="nav-text">函数内部属性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#arguments-对象"><span class="nav-text">arguments 对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#this-对象"><span class="nav-text">this 对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#caller"><span class="nav-text">caller</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数属性和方法"><span class="nav-text">函数属性和方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#length"><span class="nav-text">length</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#prototype"><span class="nav-text">prototype</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#apply"><span class="nav-text">apply()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#call"><span class="nav-text">call()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#bind"><span class="nav-text">bind()</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">田丰</span>

  
</div>


  












        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
